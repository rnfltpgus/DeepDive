# 모던 자바스크립트 Deep Dive 정리 - 출처 : 위키북스
## 1. 변수
### 1. 변수란?
> 하나의 `값을 지정하기 위해 확보한 메모리 공간` 또는 그 `메모리 공간을 식별하기 위해` 붙인 이름
>
> `값의 위치`를 가르키는 상징적인 이름

```js
// 변수는 하나의 값을 저장하기 위한 수단
const userId = 1;
const userName = 'jung';

// 객체나 배열 같은 자료구조를 사용하면 여러 개의 값을 하나로 그룹화해서 하나의 값처럼 사용
const user = { id: 1, name: 'jung'} ;
const users = [
  { id: 1, name: 'jung' },
  { id: 2, name: 'ho' }
]
```

<br>

### 2. 식별자란?
> 변수의 이름을 `식별자`라고도 함
>
> 식별자는 `어떤 값을 구별해서 식별할 수 있느 고유한 이름`을 말함 (값도 식별자로 구별해서 식별할 수 있음)
>
> 식별자는 `메모리 공간에 저장되어 있는 어떤 값`을 구별해서 식별해낼 수 있어야 함
>
> 식별자는 `값이 아니라 메모리 주소를 기억`하고 있음(식별자는 메모리 주소에 붙인 이름이라고 할 수 있음)

<br>

### 3. 변수의 선언
> `변수의 선언`은 변수를 생성하는 것을 말함
>
> `값을 저장하기 위한 메모리 공간을 확보`하고 `변수 이름과 확보된 메모리 공간의 주소를 연결`해서 `값을 저장할 수 있게 준비`하는 것
>
> 변수를 `사용하려면 반드시 선언이 필요함`(`var, let, const의 키워드`를 사용하여 선언)

<br>

### 4. 변수 선언의 실행 시점과 변수 호이스팅
> 자바스크립트 코드는 `인터프리터`에 의해 한 줄씩 순차적으로 실행되므로 `콘솔전에 변수의 선언이 먼저` 이루어 지지 않아, `자바스크립트`는 즉 `런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문` 에러가 뜬다.
>
> 이를 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 `자바스크립트 고유의 특징`을 `변수 호이스팅`이라고 함

<br>

### 5. 값의 할당
> 변수에 값을 할당(대입, 저장)할 때는 할당 연산자 `=`를 사용 (할당 연산자는 우변의 값을 좌변에 변수에 할당함)
>
> `변수 선언`은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만, `값의 할당`은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행됨
>
> 변수의 값을 새로운 값으로 `재할당하는 것도 가능`(`재할당이란?` 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말함)
>
> 만약 값을 재할당할 수 없어서 `변수에 저장된 값을 변경할 수 없다면` 변수가 아니라 `상수`라고 함(`상수`는 한번 정해지면 변하지 않는 값을 말함 - `const` 키워드로 선언시, 상수 / 하지만 `const`도 상수를 선언할 때만 사용하는 것은 아님)

```js
console.log(score); // undefined

var score = 5; // 변수 선언과 값의 할당
score = 10 // 값의 재할당 : 'var' 키워드로 선언한 변수는 값을 재할당할 수 있음

console.log(score); // 10
```

<br>

### 6. 식별자 네이밍 규칙
식별자는 어떤 값을 구별해 식별해낼 수 있는 `고유한 이름`을 말함
- 식별자는 `특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함`할 수 있음
- 단, 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)로 `시작해야 함` (숫자로 시작하는 것은 허용하지 않음)
- `예약어`는 식별자로 사용할 수 있음

`네이밍 컨벤션`은 하나 이상의 영어 단어로 구성된 식별자를 만들 때 `가독성 좋게 단어를 한눈에 구분`하기 위해 `규정한 명명규칙`
```js
// 카멜 케이스
const firstName;

// 스네이크 케이스
const first_name;

// 파스칼 케이스
const FirstName;

// 헝가리언 케이스
const strFirstName; // type + identifier
const $elem = document.getElementById('myId'); // DOM 노드
const observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```
일관성 있게 유지한다면 어떤 네이밍 컨벤션을 사용해도 괜찮지만 `자바스크립트`에서 `일반적`으로 `변수나 함수의 이름은 카멜 케이스를 사용`하고, `생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용`함

또한 `ECMAScript 사양`에 `정의`되어 있는 객체와 함수들도 `카멜 케이스와 파스칼 케이스를 사용`함

<br>

## 2. 표현식과 문
### 1. 값
> `값`은 식(표현식)이 평가되어, `생성된 결과`를 말함(변수는 하나의 값을 지정하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이라고 하였는데, `즉 변수에 할당되는 것이 값`임)
```js
// 10 + 20은 평가되어 숫자 값 30을 생성함
10 + 20 // 30
```

<br>

### 2. 리터럴
> 리터럴은 `사람이 이해할 수 있는 문자` 또는 `약속된 기호를 사용해 값을 생성하는` 표기법을 말함
```js
3 // 숫자 리터럴 3
```

<br>

### 3. 표현식
> 표현식은 값으로 평가될 수 있는 문(즉, `표현식이 평가`되면 `새로운 값을 생성`하거나 `기본 값을 참조`)
>
> 표현식은 `리터럴, 식별자(변수, 함수 등의 이름), 연산자, 함수 호출 등의 조합`으로 이루어질 수 있음(값으로 평가될 수 있는 문은 `모두 표현식`)
```js
// 리터럴 표현식
10
'Hello'

// 식별자 표현(선언이 이미 존재한다고 가정)
sum
person.name
arr[1]

// 연산자 표현식
10 + 20
sum = 10
su !== 10

// 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
square()
person.getName()
```

<br>

### 4. 문
> 문은 `프로그램을 구성하는 기본 단위`이자 최소 실행 단위
>
> 문은 여러게의 토큰으로 구성되는데, `토큰`이란 문법적인 의미를 가지며, 문법적으로 `더 이상 나눌 수 없는 코드의 기본 요소`를 의미
>
> 문은 `선언문, 할당문, 조건문, 반복문 등`으로 구분
- `변수 선언문`을 실행하면 변수가 선언
- `할당문`을 실행하면 값이 할당
- `조건문`을 실행하면 지정한 조건에 따라 실행할 코드 블록({...})이 결정되어 실행
- `반복문`을 실행하면 특정 코드 블록이 반복 실행
```js
// 변수 선언문
const x;

// 할당문
x = 5;

// 함수 선언문
function foo () {}

// 조건문
if (x >1) {console.log(x);}

// 반복문
for (let i = 0; i < 2; i++) {console.log(i);}
```

<br>

### 5. 표현식인 문과 표현식이 아닌 문
표현식인 문과 표현식이 아닌 문을 `구별하는 가장 간단하고 명료한 방법`은 `변수에 할당해 보는 것`
```js
// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.
const x;

// 1, 2, 1+2, x = 1 + 2는 모두 표현식이다.
// x = 1 + 2는 표현식이면서 완전한 문이기도 하다.
// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.
x = 1 + 2;

// 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo = var x; // SyntaxError: Unexpected token var

// 표현식인 문은 값처럼 사용할 수 있다.
var foo = x = 100;
console.log(foo); // 100
```

<br>

## 3. 데이터 타입
모든 값은 데이터 타입을 갖는다.

구분 | 데이터 타입 | 설명
--|--|--
원시타입 | 숫자 Number 타입 | 숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재
원시타입 | 문자열 String 타입 | 문자열
원시타입 | 불리언 Boolean 타입 | 논리적 참(true)과 거짓(false)
원시타입 | undefined 타입 | var 키워드로 선언된 변수에 암묵적으로 할당되는 값
원시타입 | null 타입 | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값
원시타입 | 심벌 Symbol | ES6에서 추가된 7번째 타입
객체타입 | | 객체, 함수, 배열 등

<br>

### 템플릿 리터럴
> ES6부터 템플릿 리터럴이라고하는 새로운 문자열 표기법이 도입됨
>
> 런타임에 일반 문자열로 변환되어 처리

<br>

#### 1. 멀티라인 문자열
일반 문자열 내에서는 줄바꿈(개행)이 허용되지 않는다.(일반 문자열 내에서 줄바꿈 등의 공백을 표현하려면 백슬래시(`/`)로 시작하는 이스케이프 시퀸스를 사용해야 함)
```js
// 줄바꿈과 들여쓰기가 적용된 HTML 문자열은 다음과 같이 사용해야 함
var template = '<ul>/n/t<li><a href="#">Home</a></li></ul>';

console.log(template);
```

#### 2. 표현식 삽입
문자열은 문자열 연산자 `+`를 사용해 연결할 수 있다.
`+` 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.(그 외의 경우는 덧셈 연산자로 동작)
```js
var first = 'Ung-mo';
var last = 'jung';

// ES5 : 문자열 연결
console.log('My name is ' + first + ' ' + last + '.'); // My name is Ung-mo jung.

// ES6 : 문자열 연결
console.log(`My name is ${first} ${last}.`); // My name is Ung-mo jung.

console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3

// 표현식 삽입은 반듯이 템플릿 리터럴 내에서 사용해야 함
console.log('1 + 2 = ${1 + 2}'); // 1 + 2 = ${1 + 2}
```