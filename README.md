# 모던 자바스크립트 Deep Dive 정리 - 출처 : 위키북스
## 1. 변수
### 1. 변수란?
> 하나의 `값을 지정하기 위해 확보한 메모리 공간` 또는 그 `메모리 공간을 식별하기 위해` 붙인 이름
>
> `값의 위치`를 가르키는 상징적인 이름

```js
// 변수는 하나의 값을 저장하기 위한 수단
const userId = 1;
const userName = 'jung';

// 객체나 배열 같은 자료구조를 사용하면 여러 개의 값을 하나로 그룹화해서 하나의 값처럼 사용
const user = { id: 1, name: 'jung'} ;
const users = [
  { id: 1, name: 'jung' },
  { id: 2, name: 'ho' }
]
```

<br>

### 2. 식별자란?
> 변수의 이름을 `식별자`라고도 함
>
> 식별자는 `어떤 값을 구별해서 식별할 수 있느 고유한 이름`을 말함 (값도 식별자로 구별해서 식별할 수 있음)
>
> 식별자는 `메모리 공간에 저장되어 있는 어떤 값`을 구별해서 식별해낼 수 있어야 함
>
> 식별자는 `값이 아니라 메모리 주소를 기억`하고 있음(식별자는 메모리 주소에 붙인 이름이라고 할 수 있음)

<br>

### 3. 변수의 선언
> `변수의 선언`은 변수를 생성하는 것을 말함
>
> `값을 저장하기 위한 메모리 공간을 확보`하고 `변수 이름과 확보된 메모리 공간의 주소를 연결`해서 `값을 저장할 수 있게 준비`하는 것
>
> 변수를 `사용하려면 반드시 선언이 필요함`(`var, let, const의 키워드`를 사용하여 선언)

<br>

### 4. 변수 선언의 실행 시점과 변수 호이스팅
> 자바스크립트 코드는 `인터프리터`에 의해 한 줄씩 순차적으로 실행되므로 `콘솔전에 변수의 선언이 먼저` 이루어 지지 않아, `자바스크립트`는 즉 `런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문` 에러가 뜬다.
>
> 이를 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 `자바스크립트 고유의 특징`을 `변수 호이스팅`이라고 함

<br>

### 5. 값의 할당
> 변수에 값을 할당(대입, 저장)할 때는 할당 연산자 `=`를 사용 (할당 연산자는 우변의 값을 좌변에 변수에 할당함)
>
> `변수 선언`은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만, `값의 할당`은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행됨
>
> 변수의 값을 새로운 값으로 `재할당하는 것도 가능`(`재할당이란?` 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말함)
>
> 만약 값을 재할당할 수 없어서 `변수에 저장된 값을 변경할 수 없다면` 변수가 아니라 `상수`라고 함(`상수`는 한번 정해지면 변하지 않는 값을 말함 - `const` 키워드로 선언시, 상수 / 하지만 `const`도 상수를 선언할 때만 사용하는 것은 아님)

```js
console.log(score); // undefined

var score = 5; // 변수 선언과 값의 할당
score = 10 // 값의 재할당 : 'var' 키워드로 선언한 변수는 값을 재할당할 수 있음

console.log(score); // 10
```

<br>

### 6. 식별자 네이밍 규칙
식별자는 어떤 값을 구별해 식별해낼 수 있는 `고유한 이름`을 말함
- 식별자는 `특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함`할 수 있음
- 단, 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)로 `시작해야 함` (숫자로 시작하는 것은 허용하지 않음)
- `예약어`는 식별자로 사용할 수 있음

`네이밍 컨벤션`은 하나 이상의 영어 단어로 구성된 식별자를 만들 때 `가독성 좋게 단어를 한눈에 구분`하기 위해 `규정한 명명규칙`
```js
// 카멜 케이스
const firstName;

// 스네이크 케이스
const first_name;

// 파스칼 케이스
const FirstName;

// 헝가리언 케이스
const strFirstName; // type + identifier
const $elem = document.getElementById('myId'); // DOM 노드
const observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```
일관성 있게 유지한다면 어떤 네이밍 컨벤션을 사용해도 괜찮지만 `자바스크립트`에서 `일반적`으로 `변수나 함수의 이름은 카멜 케이스를 사용`하고, `생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용`함

또한 `ECMAScript 사양`에 `정의`되어 있는 객체와 함수들도 `카멜 케이스와 파스칼 케이스를 사용`함

<br>

## 2. 표현식과 문
### 1. 값
> `값`은 식(표현식)이 평가되어, `생성된 결과`를 말함(변수는 하나의 값을 지정하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이라고 하였는데, `즉 변수에 할당되는 것이 값`임)
```js
// 10 + 20은 평가되어 숫자 값 30을 생성함
10 + 20 // 30
```

<br>

### 2. 리터럴
> 리터럴은 `사람이 이해할 수 있는 문자` 또는 `약속된 기호를 사용해 값을 생성하는` 표기법을 말함
```js
3 // 숫자 리터럴 3
```

<br>

### 3. 표현식
> 표현식은 값으로 평가될 수 있는 문(즉, `표현식이 평가`되면 `새로운 값을 생성`하거나 `기본 값을 참조`)
>
> 표현식은 `리터럴, 식별자(변수, 함수 등의 이름), 연산자, 함수 호출 등의 조합`으로 이루어질 수 있음(값으로 평가될 수 있는 문은 `모두 표현식`)
```js
// 리터럴 표현식
10
'Hello'

// 식별자 표현(선언이 이미 존재한다고 가정)
sum
person.name
arr[1]

// 연산자 표현식
10 + 20
sum = 10
su !== 10

// 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
square()
person.getName()
```

<br>

### 4. 문
> 문은 `프로그램을 구성하는 기본 단위`이자 최소 실행 단위
>
> 문은 여러게의 토큰으로 구성되는데, `토큰`이란 문법적인 의미를 가지며, 문법적으로 `더 이상 나눌 수 없는 코드의 기본 요소`를 의미
>
> 문은 `선언문, 할당문, 조건문, 반복문 등`으로 구분
- `변수 선언문`을 실행하면 변수가 선언
- `할당문`을 실행하면 값이 할당
- `조건문`을 실행하면 지정한 조건에 따라 실행할 코드 블록({...})이 결정되어 실행
- `반복문`을 실행하면 특정 코드 블록이 반복 실행
```js
// 변수 선언문
const x;

// 할당문
x = 5;

// 함수 선언문
function foo () {}

// 조건문
if (x >1) {console.log(x);}

// 반복문
for (let i = 0; i < 2; i++) {console.log(i);}
```

<br>

### 5. 표현식인 문과 표현식이 아닌 문
표현식인 문과 표현식이 아닌 문을 `구별하는 가장 간단하고 명료한 방법`은 `변수에 할당해 보는 것`
```js
// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.
const x;

// 1, 2, 1+2, x = 1 + 2는 모두 표현식이다.
// x = 1 + 2는 표현식이면서 완전한 문이기도 하다.
// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.
x = 1 + 2;

// 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo = var x; // SyntaxError: Unexpected token var

// 표현식인 문은 값처럼 사용할 수 있다.
var foo = x = 100;
console.log(foo); // 100
```

<br>

## 3. 데이터 타입
> 모든 값은 데이터 타입을 갖는다.

구분 | 데이터 타입 | 설명
--|--|--
원시타입 | 숫자 Number 타입 | 숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재
원시타입 | 문자열 String 타입 | 문자열
원시타입 | 불리언 Boolean 타입 | 논리적 참(true)과 거짓(false)
원시타입 | undefined 타입 | var 키워드로 선언된 변수에 암묵적으로 할당되는 값
원시타입 | null 타입 | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값
원시타입 | 심벌 Symbol | ES6에서 추가된 7번째 타입
객체타입 | | 객체, 함수, 배열 등

<br>

### 템플릿 리터럴
> ES6부터 템플릿 리터럴이라고하는 새로운 문자열 표기법이 도입됨
>
> 런타임에 일반 문자열로 변환되어 처리

<br>

#### 1. 멀티라인 문자열
일반 문자열 내에서는 줄바꿈(개행)이 허용되지 않는다.(일반 문자열 내에서 줄바꿈 등의 공백을 표현하려면 백슬래시(`/`)로 시작하는 이스케이프 시퀸스를 사용해야 함)
```js
// 줄바꿈과 들여쓰기가 적용된 HTML 문자열은 다음과 같이 사용해야 함
var template = '<ul>/n/t<li><a href="#">Home</a></li></ul>';

console.log(template);
```

#### 2. 표현식 삽입
문자열은 문자열 연산자 `+`를 사용해 연결할 수 있다.
`+` 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.(그 외의 경우는 덧셈 연산자로 동작)
```js
var first = 'Ung-mo';
var last = 'jung';

// ES5 : 문자열 연결
console.log('My name is ' + first + ' ' + last + '.'); // My name is Ung-mo jung.

// ES6 : 문자열 연결
console.log(`My name is ${first} ${last}.`); // My name is Ung-mo jung.

console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3

// 표현식 삽입은 반듯이 템플릿 리터럴 내에서 사용해야 함
console.log('1 + 2 = ${1 + 2}'); // 1 + 2 = ${1 + 2}
```

<br>

## 4. 연산자
> 연산자는 하나 이상의 표현식을 대상으로 `산술, 할당, 비교, 논리, 타입, 지수 연산 등`을 수행해 하나의 값을 만든다.(이때 `연산의 대상을 피연산자`라 함)

<br>

### 1. 산술 연산자
#### 1. 이항 산순 연산자
이항 산순 연산자는 2개의 피연산자를 산출 연산하여 숫자 값을 만든다.
이항 산순 연산자 | 의미 | 부수효과
--|--|--
+|덧셈|x
-|뺄셈|x
*|곱셈|x
/|나눗셈|x
%|나머지|x

#### 2. 단항 산술 연산자
단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.
단항 산순 연산자 | 의미 | 부수효과
--|--|--
++|증가|o
--|감소|o
+|어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다.|x
-|양수를 음수로, 음수를 양수로 반전한 값을 반환한다.|x
```js
var x = 1;

// 이항 산술 연산자와 달리 증가/감소(++/--) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.

x++; // x = x + 1;
x--; // x = x - 1;
```
#### 3. 문자열 연결 연산자
`+` 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작

<br>

### 2. 할당 연산자
> 할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.
>
> 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수 효과가 있다.

할당 연산자 | 예 | 동일 표현 | 부수 효과
--|--|--|--
= | x = 5 | x = x + 5 | o
+= | x += 5 | x = x + 5 | o
-= | x -= 5 | x = x - 5 | o
*= | x *= 5 | x = x * 5 | o
/= | x /+ 5 | x = x / 5 | o
%= | x %= 5 | x = x % 5 | o

<br>

### 3. 비교 연산자
> 비교연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.
>
> 비교 연산자는 `if문이나 for문과 같은 제어문의 조건식`에서 주로 사용한다.

#### 1. 동등/일치 비교 연산자
비교 연산자 | 의미 | 사례 | 설명 | 부수 효과
--|--|--|--|--
== | 동등 비교 | x == y | x와 y의 값이 같음 | x
=== | 일치 비교 | x === y | x와 y의 값과 타입이 같음 | x
!= | 부동등 비교 | x 1= y | x와 y의 값이 다름 | x
!== | 불일치 비교 | x !== y | x와 y의 값과 타입이 다름 | x
```js
// 동등 비교
5 == 5; // true

// 동등 비교(==) 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교함
5 == '5'; // true

// 일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환
5 === '5'; // false
```

#### 2. 대소 관계 비교 연산자
피연산자의 크기를 비교하여 불리언 값을 반환
대소 관계 비교 연산자 | 예제 | 설명 | 부수 효과
--|--|--|--
` > `| x > y | x가 y보다 크다 | x
` < ` | x < y | x가 y보다 작다 | x
` >= ` | x >= y | x가 y보다 크거나 같다 | x
` <= ` | x <= y | x가 y보다 작거나 같다 | x

### 4. 삼항 조건 연산자
> 조건식의 평가 결과에 따라 반환할 값을 결정
>
> `조건식 ? 조건식이 true일 때 반활할 값 : 조건식이 false일 때 반환할 값`
>
> 삼항 조건 연산자는 첫 번째 피 연산자가 true로 평가되면 두번째 피연산자를 반환하고, 첫 번째 피연산자가 false로 평가되면 세 번째 피연산자를 반환한다.
>
> 즉, 삼항 조건 연산자는 두 번째 피연산자 또는 세 번째 피연산자로 평가되는 표현식
>
> 조건에 따라 수행해야 할 문이 하나면 삼항연산자, 여러 개라면 if...else문의 가독성이 좋음
```js
var x = 2;

// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.
var result = x % 2 ? '홀수' : '짝수';

console.log(result); //짝수
```
if..else문을 사용해도 삼항 조건 연산자 표현식과 유사하게 처리 가능
```js
var x = 2, result;

// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.
if (x % 2) result = '홀수';
else       result = '짝수';

console.log(result); //짝수
```

<br>

### 5. 논리 연산자
논리 연산자는 우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산
논리 연산자 | 의미 | 부수효과
--|--|--
ㅣㅣ |논리합(OR)|x
&&|논리곱(AND)|x
!|부정(NOT)|x
```js
// 논리합(||) 연산자
true || true; // true
true || false; // true
false || true; // true
false || false; // false

// 논리곱(&&) 연산자
true && true // true
true && false // false
false && true // false
false && false // false

// 논리 부정(!) 연산자
!true; // false
!false; // true

// 암묵적 타입 변환
!0; // true
!'Hello'; // false
```

<br>

### 6. typeof 연산자
> 피연산자의 데이터 타입을 문자열로 반환(typeof 연산자는 7가지 문자열)
> - `string, number, boolean, undefined, symbol, object, function` 증 `하나`를 반환

<br>

### 7. 지수 연산자
> `ES7에서 도입된 지수 연산자`는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환
> 이항 연산자 중 `우선순위가 가장 높다.`
```js
2 ** 2; // 4
2 ** 2.5; // 5.65685424949238
2 ** 0; // 1
2 ** -2 // 0.25
```
지수 연산자가 도입되기 이전에는 `Math.pow 메서드`를 사용했었음
```js
Math.pow(2, 2) // 4
Math.pow(2, 2.5) // 5.65685424949238
Math.pow(2, 0) // 1
Math.pow(2, -2) // 0.25
```
`지수 연산자`는 `Math.pow 메서드`보다 `가독성이 좋음`을 알수 있다.
```js
2 ** (3**2); // 512
Math.pow(2, Math.pow(3, 2)); // 512
```

<br>

## 5. 객체 리터럴
오늘은 윈도우에서 로그인을 해보았다

<br>

## 6. 일단 바코에 집중